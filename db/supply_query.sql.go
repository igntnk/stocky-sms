// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: supply_query.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createSupply = `-- name: CreateSupply :one
insert into supply (comment, desired_date, responsible_user, edited_date, cost) values ($1, $2, $3, $4, $5) returning uuid
`

type CreateSupplyParams struct {
	Comment         pgtype.Text
	DesiredDate     pgtype.Timestamp
	ResponsibleUser string
	EditedDate      pgtype.Timestamp
	Cost            pgtype.Numeric
}

func (q *Queries) CreateSupply(ctx context.Context, arg CreateSupplyParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, createSupply,
		arg.Comment,
		arg.DesiredDate,
		arg.ResponsibleUser,
		arg.EditedDate,
		arg.Cost,
	)
	var uuid pgtype.UUID
	err := row.Scan(&uuid)
	return uuid, err
}

const deleteSupply = `-- name: DeleteSupply :one
delete from supply where uuid = $1 returning uuid
`

func (q *Queries) DeleteSupply(ctx context.Context, uuid pgtype.UUID) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, deleteSupply, uuid)
	err := row.Scan(&uuid)
	return uuid, err
}

const getActiveSupplies = `-- name: GetActiveSupplies :many
select uuid, comment, creation_date, desired_date, status, responsible_user, edited, edited_date, cost from supply where status != 'done'
`

func (q *Queries) GetActiveSupplies(ctx context.Context) ([]Supply, error) {
	rows, err := q.db.Query(ctx, getActiveSupplies)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Supply
	for rows.Next() {
		var i Supply
		if err := rows.Scan(
			&i.Uuid,
			&i.Comment,
			&i.CreationDate,
			&i.DesiredDate,
			&i.Status,
			&i.ResponsibleUser,
			&i.Edited,
			&i.EditedDate,
			&i.Cost,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSupplyById = `-- name: GetSupplyById :one
select uuid, comment, creation_date, desired_date, status, responsible_user, edited, edited_date, cost from supply where uuid = $1
`

func (q *Queries) GetSupplyById(ctx context.Context, uuid pgtype.UUID) (Supply, error) {
	row := q.db.QueryRow(ctx, getSupplyById, uuid)
	var i Supply
	err := row.Scan(
		&i.Uuid,
		&i.Comment,
		&i.CreationDate,
		&i.DesiredDate,
		&i.Status,
		&i.ResponsibleUser,
		&i.Edited,
		&i.EditedDate,
		&i.Cost,
	)
	return i, err
}

const updateSupplyInfo = `-- name: UpdateSupplyInfo :exec
update supply set comment = $1, desired_date = $2, status = $3, responsible_user = $4, edited = true, edited_date = now(), cost = $5 where uuid = $6
`

type UpdateSupplyInfoParams struct {
	Comment         pgtype.Text
	DesiredDate     pgtype.Timestamp
	Status          SupplyStatus
	ResponsibleUser string
	Cost            pgtype.Numeric
	Uuid            pgtype.UUID
}

func (q *Queries) UpdateSupplyInfo(ctx context.Context, arg UpdateSupplyInfoParams) error {
	_, err := q.db.Exec(ctx, updateSupplyInfo,
		arg.Comment,
		arg.DesiredDate,
		arg.Status,
		arg.ResponsibleUser,
		arg.Cost,
		arg.Uuid,
	)
	return err
}
